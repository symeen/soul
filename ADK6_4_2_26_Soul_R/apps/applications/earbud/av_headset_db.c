/*
 * THIS FILE IS AUTOGENERATED, DO NOT EDIT!
 *
 * generated by gattdbgen from av_headset_db.db_
 */

#include <panic.h>
#include <string.h>
#include "av_headset_db.h"

/* Static GATT database */
const uint16 gattDatabase[] = {
    /* 0001: Primary Service 1801 */
    0x0002, 0x0118,
    /* 0002: Characteristic Declaration 2a05 */
    0x3005, 0x2003, 0x0005, 0x2a00,
    /* 0003:  */
    0xd000,
    /* 0004: Client Characteristic Configuration */
    0x6402, 0x0000,
    /* 0005: Characteristic Declaration 2b29 */
    0x3005, 0x0a06, 0x0029, 0x2b00,
    /* 0006: . */
    0xd401, 0x0000,
    /* 0007: Primary Service 1800 */
    0x0002, 0x0018,
    /* 0008: Characteristic Declaration 2a00 */
    0x3005, 0x0209, 0x0000, 0x2a00,
    /* 0009:  */
    0xd400,
    /* 000a: Characteristic Declaration 2a01 */
    0x3005, 0x020b, 0x0001, 0x2a00,
    /* 000b:  */
    0xd400,
    /* 000c: Primary Service 00001100-d102-11e1-9b23-00025b00a5a5 */
    0x0010, 0xa5a5, 0x005b, 0x0200, 0x239b, 0xe111, 0x02d1, 0x0011, 0x0000,
    /* 000d: Characteristic Declaration 00001101-d102-11e1-9b23-00025b00a5a5 */
    0x3013, 0x080e, 0x00a5, 0xa500, 0x5b02, 0x0023, 0x9be1, 0x1102, 0xd101, 0x1100, 0x0000,
    /* 000e: . */
    0xcd01, 0x0000,
    /* 000f: Characteristic Declaration 00001102-d102-11e1-9b23-00025b00a5a5 */
    0x3013, 0x1210, 0x00a5, 0xa500, 0x5b02, 0x0023, 0x9be1, 0x1102, 0xd102, 0x1100, 0x0000,
    /* 0010: . */
    0xcc01, 0x0000,
    /* 0011: Client Characteristic Configuration */
    0x6c00,
    /* 0012: Characteristic Declaration 00001103-d102-11e1-9b23-00025b00a5a5 */
    0x3053, 0x1613, 0x00a5, 0xa500, 0x5b02, 0x0023, 0x9be1, 0x1102, 0xd103, 0x1100, 0x0000,
    /* 0013: . */
    0xcd01, 0x0000,
    /* 0014: Client Characteristic Configuration */
    0x6c00,
    /* 0015: Primary Service 6e400001-b5a3-f393-e0a9-e50e24dcca9e */
    0x0010, 0x9eca, 0xdc24, 0x0ee5, 0xa9e0, 0x93f3, 0xa3b5, 0x0100, 0x406e,
    /* 0016: Characteristic Declaration 6e400002-b5a3-f393-e0a9-e50e24dcca9e */
    0x3013, 0x0817, 0x009e, 0xcadc, 0x240e, 0xe5a9, 0xe093, 0xf3a3, 0xb502, 0x0040, 0x6e00,
    /* 0017: . */
    0xcc01, 0x0000,
    /* 0018: Client Characteristic Configuration */
    0x6c00,
    /* 0019: Characteristic Declaration 6e400003-b5a3-f393-e0a9-e50e24dcca9e */
    0x3013, 0x101a, 0x009e, 0xcadc, 0x240e, 0xe5a9, 0xe093, 0xf3a3, 0xb503, 0x0040, 0x6e00,
    /* 001a: . */
    0xcc01, 0x0000,
    /* 001b: Client Characteristic Configuration */
    0x6c00,
};

/* SDP service snippets */
const uint8 gatt_sdp_class[] = {
    /* UINT16: ServiceClassIDList 0x0001 */
    0x09, 0x00, 0x01, 0x35, /* add length + type + UUID */
};

const uint8 gatt_sdp_prot[] = {
    /* UINT16: ProtocolDescriptorList 0x0004 */
    0x09, 0x00, 0x04,
    /* Segment: 19 bytes */
    0x35, 0x13,
    /** Segment: 6 bytes */
    /**/ 0x35, 0x06,
    /**** UUID16: L2CAP */
    /****/ 0x19, 0x01, 0x00,
    /**** UINT16: ATT PSM */
    /****/ 0x09, 0x00, 0x1f,
    /** Segment: 9 bytes */
    /**/ 0x35, 0x09,
    /**** UUID16: ATT */
    /****/ 0x19, 0x00, 0x07,
    /**** UINT16: start handle, to be filled later */
    /****/ 0x09, 0x00, 0x00,
    /**** UINT16: end handle, to be filled later */
    /****/ 0x09, 0x00, 0x00,

    /* UINT16: BrowseGroupList 0x0005 */
    0x09, 0x00, 0x05,
    /* Segment: 3 bytes */
    0x35, 0x03,
    /** UUID16: PublicBroseGroup */
    /**/ 0x19, 0x10, 0x02  
};

#define OFFS_START      0x0013  /* offset to starting handle */
#define OFFS_END        0x0016  /* offset to ending handle */

#define UUID_IS_16      0x0000  /* flag indicating 16-bit UUID */
#define UUID_IS_32      0x4000  /* flag indicating 32-bit UUID */
#define UUID_IS_128     0x8000  /* flag indicating 128-bit UUID */

/* DataElement Header for UUID16 (Type:0b00011 Size:0b001)
 * See Core V4.0 SDP Specification P221 Sec 3.2 & 3.3 */
#define SDP_UUID16      0x19
/* DataElement Header for UUID32 (Type:0b00011 Size:0b010)
 * See Core V4.0 SDP Specification P221 Sec 3.2 & 3.3 */
#define SDP_UUID32      0x1A
/* DataElement Header for UUID128 (Type:0b00011 Size:0b100)
 * See Core V4.0 SDP Specification P221 Sec 3.2 & 3.3 */
#define SDP_UUID128     0x1c

const struct 
{
    uint16      offs;
    uint16      start;
    uint16      end;
} sdp_data[] = {
    { UUID_IS_16  | 0x0010, 0x0007, 0x000b },     /* GAP_SERVICE */
    { UUID_IS_128 | 0x0055, 0x0015, 0xffff },     /* BME300_SERVICE */
};

uint8 *GattGetServiceRecord(gatt_sdp service, uint16 *len)
{
    uint8 *sdp;
    uint8 *p_sdp;
    uint16 uuidlen;
    uint16 offs;

    if (service == gatt_sdp_last)
    {
        *len = 0U;
        return NULL;
    }

    if (sdp_data[service].offs & UUID_IS_128)
        /* 128-bit UUID */
    {
        /* 16 octets */
        uuidlen = 16U;
    }
    else if (sdp_data[service].offs & UUID_IS_32)
        /* 32-bit UUID */
    {
        /* 4 octets */
        uuidlen = 4U;
    }
    else
        /* 16-bit UUID */
    {
        /* 2 octets */
        uuidlen = 2U;
    }
    
    /* allocate memory */
    *len = sizeof(gatt_sdp_class) + sizeof(gatt_sdp_prot) + 2 + uuidlen ;
    sdp = PanicUnlessMalloc(*len);

    memmove(sdp, gatt_sdp_class, sizeof(gatt_sdp_class));
    p_sdp = &sdp[sizeof(gatt_sdp_class)];
    *p_sdp++ = uuidlen + 1;
    if ( sdp_data[service].offs & UUID_IS_128 )
    {
        *p_sdp++ = SDP_UUID128;
    }
    else if ( sdp_data[service].offs & UUID_IS_32 )
    {
        *p_sdp++ = SDP_UUID32;
    }
    else
    {
        *p_sdp++ = SDP_UUID16;
    }

    /* extract the UUID from the ATT database data */
    for (offs = ( sdp_data[service].offs
            & ~( UUID_IS_128 | UUID_IS_32 | UUID_IS_16 ) ); uuidlen; offs--)
    {
	/* The values below are explictly converted to 8-bits by zeroing of higher bytes, 
	 * as on bluecore uint8 is not necessarily 8-bits */	    
        *p_sdp++ = ( gattDatabase[offs] & 0xFF );
        *p_sdp++ = ( gattDatabase[offs] >> 8 ) & 0xFF;
        uuidlen -= 2;
    }

    memmove(p_sdp, gatt_sdp_prot, sizeof(gatt_sdp_prot));
    p_sdp[OFFS_START] = sdp_data[service].start >> 8;
    p_sdp[OFFS_START + 1] = sdp_data[service].start;
    p_sdp[OFFS_END] = sdp_data[service].end >> 8;
    p_sdp[OFFS_END + 1] = sdp_data[service].end;

    return sdp;
}

uint16 *GattGetDatabase(uint16 *len)
{
    uint16 *rc = PanicUnlessMalloc(sizeof(gattDatabase));
    *len = sizeof(gattDatabase);
    memmove(rc, gattDatabase, sizeof(gattDatabase));
    return rc;
}

uint16 GattGetDatabaseSize(void)
{
    return sizeof(gattDatabase);
}

/* End-of-File */
